# 历史缺陷记录

## 缺陷记录模板

```markdown
### BUG-XXX: 缺陷标题
- **发现时间**: YYYY-MM-DD
- **严重级别**: P0/P1/P2/P3
- **影响版本**: vX.Y.Z
- **修复版本**: vX.Y.Z
- **状态**: 已修复/已验证/已关闭

**问题描述**
简要描述缺陷现象

**复现步骤**
1. 步骤 1
2. 步骤 2
3. 步骤 3

**预期结果**
描述预期行为

**实际结果**
描述实际行为

**根因分析**
链接到 RCA 报告: [RCA-XXX](rca/RCA-XXX.md)

**修复方案**
描述修复方法

**预防措施**
- 预防措施 1
- 预防措施 2

**相关提交**
- commit-hash: 提交描述
```

---

## 已记录缺陷

### BUG-001: 节点重复启动导致事件处理器重复注册
- **发现时间**: 2024-02-20
- **严重级别**: P1
- **影响版本**: v1.0.0
- **修复版本**: v1.0.1
- **状态**: 已关闭

**问题描述**
当并发调用 `node.start()` 时，事件处理器会被重复注册，导致消息重复处理。

**复现步骤**
1. 创建 SilkNode 实例
2. 同时调用两次 `start()`
3. 发送消息
4. 观察到消息被处理两次

**预期结果**
第二次 `start()` 调用应该被忽略或抛出错误

**实际结果**
事件处理器被重复注册

**根因分析**
缺少启动状态检查，没有防止并发启动的机制。

**修复方案**
添加 `starting` 标志和状态检查：
```typescript
if (this.starting || this.started) {
  this.logger.warn('Node start already in progress or completed');
  return;
}
```

**预防措施**
- 添加并发控制测试用例
- 代码审查时关注状态管理
- 使用 AbortController 管理事件监听

**相关提交**
- a1b2c3d: fix: prevent concurrent node start

---

### BUG-002: 节点停止时组件清理顺序错误
- **发现时间**: 2024-02-21
- **严重级别**: P1
- **影响版本**: v1.0.0
- **修复版本**: v1.0.1
- **状态**: 已关闭

**问题描述**
节点停止时，组件按错误顺序清理，导致 DHT 操作在 libp2p 停止后执行，引发异常。

**复现步骤**
1. 启动节点并启用 DHT
2. 执行一些 DHT 操作
3. 停止节点
4. 观察到异常日志

**预期结果**
节点优雅停止，无异常

**实际结果**
抛出 `Error: node not started` 异常

**根因分析**
组件停止顺序与依赖关系相反，DHT 依赖于 libp2p，但 libp2p 先于 DHT 停止。

**修复方案**
调整停止顺序：
```typescript
// 反向停止依赖组件
await this.dhtRouting.stop();
await this.peerDiscovery.stop();
await this.libp2p.stop();
```

**预防措施**
- 文档化组件依赖关系
- 添加停止顺序测试
- 使用依赖注入管理生命周期

**相关提交**
- b2c3d4e: fix: correct component stop order

---

### BUG-003: IPv6 私有地址未被正确识别
- **发现时间**: 2024-02-22
- **严重级别**: P2
- **影响版本**: v1.0.0
- **修复版本**: v1.0.2
- **状态**: 已关闭

**问题描述**
`isPrivateAddress()` 方法只检查 IPv4 私有地址，IPv6 本地地址被错误地识别为公网地址。

**复现步骤**
1. 在 IPv6 环境启动节点
2. 调用 `getNetworkInfo()`
3. 观察到 IPv6 本地地址被标记为公网地址

**预期结果**
IPv6 本地地址 (`::1`, `fe80:`, `fc00:`, `fd00:`) 应该被识别为私有地址

**实际结果**
IPv6 地址被标记为公网地址

**根因分析**
缺少 IPv6 私有地址范围检查。

**修复方案**
添加 IPv6 检查：
```typescript
if (addrStr.includes('/ip6/::1') ||
    addrStr.includes('/ip6/fe80:') ||
    addrStr.includes('/ip6/fc') ||
    addrStr.includes('/ip6/fd')) {
  return true;
}
```

**预防措施**
- 添加网络地址测试用例
- 使用标准库进行地址分类
- 定期审查网络相关代码

**相关提交**
- c3d4e5f: fix: add IPv6 private address detection

---

### BUG-004: 消息 ID 冲突导致消息丢失
- **发现时间**: 2024-02-22
- **严重级别**: P0
- **影响版本**: v1.0.0
- **修复版本**: v1.0.2
- **状态**: 已关闭

**问题描述**
在高并发场景下，使用时间戳作为消息 ID 导致冲突，后续消息被丢弃。

**复现步骤**
1. 快速发送多条消息
2. 观察消息接收情况
3. 发现部分消息丢失

**预期结果**
每条消息都有唯一 ID，不会被错误去重

**实际结果**
相同时间戳的消息被去重

**根因分析**
消息 ID 生成逻辑使用 `Date.now()`，在高并发下可能重复。

**修复方案**
使用 UUID 或添加序列号：
```typescript
id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
```

**预防措施**
- 使用 UUID 库生成唯一 ID
- 添加消息 ID 唯一性测试
- 实现消息序列号机制

**相关提交**
- d4e5f6g: fix: use unique message IDs

---

## 缺陷统计

### 按级别统计
| 级别 | 数量 | 占比 |
|-----|------|------|
| P0 | 1 | 25% |
| P1 | 2 | 50% |
| P2 | 1 | 25% |
| P3 | 0 | 0% |

### 按模块统计
| 模块 | 数量 | 占比 |
|-----|------|------|
| Core | 3 | 75% |
| Network | 1 | 25% |
| Routing | 0 | 0% |
| Protocol | 0 | 0% |

### 按类型统计
| 类型 | 数量 | 占比 |
|-----|------|------|
| 并发问题 | 1 | 25% |
| 逻辑错误 | 2 | 50% |
| 边界条件 | 1 | 25% |
